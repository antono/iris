---------------------------------------------------------------------------
Missing or Incompleteness
---------------------------------------------------------------------------

We are not currently destroying threads ever. After they are created they
stay created until the end of the process. We need to find a way to
periodically walk the free-list to shutdown old threads.

IrisTask

	Start implementing the task object.  We probably need to forge
	forward a bit with the arbiter to only allow a single receive
	at a time.

IrisService

	A concurrent service implementation which should aim to ease
	developing service providers that need to do some work items
	concurrently, and others exclusively.  Think of a web-server
	that would need to do a configuration change.

IrisScheduler

	We need a better way to manage the min-threads, max-threads
	properties.

	Either add use of execution notify, or remove it from the
	signatures.

IrisArbiter

	Add an arbiter similar to CCR interleave that does restrictions
	for concurrent vs exclusive messages.

---------------------------------------------------------------------------
Optimization TODO's
---------------------------------------------------------------------------

iris_message_unref()

	This method shows up on the profile. It has considerable wait time
	which is probably attributed to using g_slice_*(). We should look
	at options from pulse audio which use lock-free algorithms.

	The changes here should also be applied to the IrisThreadWork
	data structure.

	Lets verify this is really an issue, I highly doubt it now.  The
	frequent allocations for thread work might be a good idea to move
	to a free list though, so we reduce pressure on gslice.

iris_port_post()
iris_receiver_deliver_real()

	These related methods have significant wait time. This could be
	both from the atomic operations as well as the locks incurred.
	How can we reduce the potential for lock in these situations?

