---------------------------------------------------------------------------
Code cleanliness TOOD's
---------------------------------------------------------------------------

---------------------------------------------------------------------------
Missing or Incompleteness
---------------------------------------------------------------------------

We are not currently destroying threads ever. After they are created they
stay created until the end of the process. We need to find a way to
periodically walk the free-list to shutdown old threads.

---------------------------------------------------------------------------
Optimization TODO's
---------------------------------------------------------------------------

g_time_val_compare()

	Shows up on the profile. We are calling this between every work-
	item in the worker thread. Lets start with inline-ing it, but how
	can we avoid the need to check the timings at all?

iris_message_unref()

	This method shows up on the profile. It has considerable wait time
	which is probably attributed to using g_slice_*(). We should look
	at options from pulse audio which use lock-free algorithms.

	The changes here should also be applied to the IrisThreadWork
	data structure.

iris_port_post()
iris_receiver_deliver_real()

	These related methods have significant wait time. This could be
	both from the atomic operations as well as the locks incurred.
	How can we reduce the potential for lock in these situations?

iris_thread_worker()

	This method showed up with lots of wait time. This is probably
	just from the waiting for control messages from the scheduler
	manager.

IrisMessage

	Add a GValue into the message for a single value embedded within
	the message. This will allow for a key-less data value.  Which
	means you can store data and still keep the low-overhead of
	avoiding the hashtable.

IrisTask

	Start implementing the task object.  We probably need to forge
	forward a bit with the arbiter to only allow a single receive
	at a time.

IrisService

	A concurrent service implementation which should aim to ease
	developing service providers that need to do some work items
	concurrently, and others exclusively.  Think of a web-server
	that would need to do a configuration change.

IrisScheduler

	We need a better way to manage the min-threads, max-threads
	properties.

	Either add use of execution notify, or remove it from the
	signatures.

IrisWSQueue

	The first time we look through for items we should use a timeout
	of zero so that we do not block on the global queue.  However,
	if no items were found or stolen, we should look through again
	this time blocking the timed amount on the global queue.

	PATCHED.

